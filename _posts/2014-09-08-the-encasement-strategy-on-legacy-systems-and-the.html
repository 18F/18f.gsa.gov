---
layout: post

title: "The encasement strategy: on legacy systems and the importance of APIs"

image: /assets/blog/encasement/encasement1.png

description: "In 1986 a nuclear reactor known as Chernobyl released harmful radioactivity which spread over much of the western USSR and Europe. The core of this reactor remains a glowing, ineradicable mass of deadly radioactive lava in the middle of a large Exclusion Zone unfit for human habitation."

authors:
- robert
- mhz

tags:
- api
- how we work
---

<p>In 1986 a nuclear reactor known as <a href="https://en.wikipedia.org/wiki/Chernobyl_disaster">Chernobyl</a> released harmful radioactivity which spread over much of the western USSR and Europe. The core of this reactor remains a glowing, ineradicable mass of deadly radioactive lava in the middle of a large Exclusion Zone unfit for human habitation.</p>

<!-- more -->

<p>The Chernobyl reactor core could not be removed. It was and is too big, too hot, and there is no where for it to go. Instead, it was entombed in a concrete sarcophagus where it will radiate harmlessly for decades if not centuries. This was unfortunately the best outcome that could be achieved. In the software industry, I’ve often seen this same approach used with legacy software systems. I call it <em>The Encasement Strategy</em>.</p>

<p>Legacy systems make everyone that has to touch them queasy, from the software engineers to the managers. But most especially there comes a time when the system no longer serves the most important constituent of all, the customer. This not only contributes to inefficiency, but can sometimes have detrimental effects on the users of a system.</p>

<p><img src="/assets/blog/encasement/encasement1.png" alt="legacy software can be toxic to customers and stakeholders"/></p>

<p>Like Chernobyl, these systems are toxic; but unlike a power plant, what they once produced is not fungible with other sources. There is often no replacement for the legacy system.</p>

<p><strong>The basic mechanism for remediating such a system comes straight out of Computer Programming 101: you create a well-designed interface.</strong> In modern terms, this is an <em>Application Programming Interface</em> or API. That term API used to be more general, but now it almost always connotes a web-based interface accessed through HTTP and usually using JSON as its data format.</p>

<p>An API is an <em>inter-face</em>, a face, a façade or a wall <em>between</em>. It allows the user blissful ignorance of what precisely is behind the wall. You need only worry about what comes and goes through the gate. What lies beyond—whether it’s magic, or a red-hot mass of legacy code—is no longer the user’s concern.The customers on the user side of the API are protected from the toxins, leaving the engineers to deal with implementation.</p>

<p><img src="/assets/blog/encasement/encasement2.png" alt=""/></p>

<p>There is something magical about this basic act of defining an interface. To paraphrase <a href="https://bfi.org/about-fuller">Buckminster Fuller</a>, to <em>define</em> is <em>divine</em>. It creates something simple and understandable from nothing, something you can grab onto, something solid.</p>

<p><strong>By defining an API, you can begin to immediately serve the customer, because you can build a modern GUI on top of it, unencumbered by the legacy of the past.</strong> You can begin to build what history has shown needs to be built to serve the customer, whether that is the US citizen at large, or a division of an office, or a bureau of an agency. You may choose to allow outsiders to directly make calls to your API, but even if you do not do this, you can create independence of the legacy technology.</p>

<p>Sometimes, such an API can be constructed based on a clear engineering understanding of the internals of the legacy system. This is the best approach; however, it may be impractical if the knowledge and understanding of the system has been lost. In such a case, programmers are wont to resort to reverse engineering solutions, as I did <a href="https://github.com/18F/gsa-advantage-scrape">recently</a>. Any system which offers a <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> (graphical user interface) to users can be reverse engineered to construct a programmatic interface on top of that interface. We generally call this <a href="https://en.wikipedia.org/wiki/Web_scraping">scraping</a> the GUI, and it isn&#8217;t pretty. It leads to the absurd architectural diagram of a GUI on top of an API on top of a GUI on top of a miasma. But it gets the job done, and that is what a pragmatic software engineer must care about: serving the customer.</p>

<p><img src="/assets/blog/encasement/encasement3.png" alt="build an API and an interface to scrape information from a legacy system"/></p>

<p>Once a valuable API is defined, there is a wall between decisions about how to effectively use the API that completely divorces them from decisions about what to do with the code that implements the API. Efforts to rewrite the legacy system may proceed mostly independent of the efforts to build functionality that uses the API. Or, efforts to rewrite it may not proceed at all—the Encasement Strategy.</p>

<p>As an engineer who loves hard problems, the idea of leaving a legacy system in place and not attempting to rewrite it is a serious challenge. But I think we should always make that decision independent of decisions on how to best serve the customer.</p>

<p>Let us work through a highly contrived thought experiment. Imagine that 100 years from now there is a team of 5 highly skilled specialists, known as <em>Software Conservationists</em>. Their sole job is to maintain the sealed-off core of the legacy system which is STILL implementing an API that serves the US Citizen. Just like Art Conservationists working at the Smithsonian today, future citizens could train to do it.</p>

<p>The Software Conservationists are employed because of two decisions made today:</p>

<ol><li>A decision to create an API </li>
<li>A decision not to rewrite the legacy system </li>
</ol><p>Let us say that it costs $1,000,000 present-day dollars to maintain this team every year from now until the <a href="https://en.wikipedia.org/wiki/Corium_(nuclear_reactor)">corium</a> in Chernobyl is no longer hot.</p>

<p>How much money would you have to save this year in order to justify paying out an annuity of $1,000,000? Assuming that one could obtain a risk-free 3% after-inflation return on an investment (or, in accounting terms, <a href="https://en.wikipedia.org/wiki/Discount_rate">discount rate</a> of 3%), how much money would you have to save to justify making a decision today that creates the Software Conservationists profession a century from now? The answer is an elementary <a href="http://www.ultimatecalculators.com/present_value_annuity_calculator.html">present value calculation</a>: $34 million or more.</p>

<p>If a realist who is keeping her users top of mind can save the US Taxpayer $34 million today, she should employ the Encasement Strategy and not be ashamed of it. Such a realist should of course recognize the long-term effects of Software Conservation versus the creation of a new, modern system.</p>

<p>Whether the details of your toxic system lead you to begin the legacy rewrite immediately or to employ the Encasement Strategy of delaying the rewrite indefinitely, get started on a <a href="http://apievangelist.com">well-designed API</a> today.</p>

<p><strong>Postscript</strong></p>

<p>After this article was published, a kind tweet by David Illsley suggested that this was the <a href="http://martinfowler.com/bliki/StranglerApplication.html">Strangler Pattern</a> which Martin Fowler has blogged about.  Martin Fowler credits a <a href="http://cdn.pols.co.uk/papers/agile-approach-to-legacy-systems.pdf">paper</a> by Chris Stevenson and Andy Pols as the initiator of this idea, and further more references a set of <a href="http://paulhammant.com/2013/07/14/legacy-application-strangulation-case-studies/">case studies</a> collected by Paul Hammant.</p>